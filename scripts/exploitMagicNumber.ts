import "@ethersproject/abstract-provider"
import { ethers, getNamedAccounts, network } from "hardhat"


import * as dotenv from 'dotenv'
dotenv.config()


const executeExploit= async()=>{
    if(network.name==="rinkeby"){
        const {exploiter}=await getNamedAccounts()
        const exploiterAcc= await ethers.getSigner(exploiter)
        const magicNum= await ethers.getContractAt('MagicNum',process.env.MAGIC_NUM_ADDRESS as string)
        const returnCode="f3" //return memory[offset:offset+length] | stack: offset, length
        const push50="60"+"50" //60 PUSH1 code
        const push32="60"+"20" //20 is 32 in hexadecimal
        const mstore="52" // memory[offset:offset+32] = value | stack: offset, value
        const push42="60"+"2a" //20 is 42 in hexadecimal
        const runcode=`${push42}${push50}${mstore}${push32}${push50}${returnCode}` //Every function we call, no matters its signature, will run this runcode
        //Put 42 in the stack
        //Put 50 in the stack
        //Now do memory[offset:offset+32] = value, where offset will be 0x50, and 42 will be the value. Pop this 2 values from the stack
        //Put 32 in the stack
        //Put 50 in the stack
        //return memory[offset:offset+length], where offset will be 0x50 and length will be 32. Pop this 2 values from stack. Now the stack will be empty
        
        const pushRuncodeLength="600a" // PUSH1 0x0a (10 bytes, which is the runcode length)
        const pushInitializationCodeLength="600c" // PUSH1 0x0c (12 byte, we will see that these code will take this number of bytes)
        const pushMemoryDestination="6000" // PUSH1 0x00 (0, which will be our memory index)
        const codecopy="39"

        //pushRuncodeLength, pushMemoryDestination to meet return stack requirement
        const returnEvm="f3" // RETURN, we need to go back to the EVM
        const initializationCode=`${pushRuncodeLength}${pushInitializationCodeLength}${pushMemoryDestination}${codecopy}${pushRuncodeLength}${pushMemoryDestination}${returnEvm}`
        // Put 10 in the stack (RUNCODE length)
        // Put 12 in the stack (Length of the initialization code)
        // Put 0 in the stack
        // Code copy(destOffset, offset, length): memory[destOffset:destOffset+length] = msg.data[offset:offset+length]
        // Now we need to return something, we choose to return our code, although this could have been anything
        const transaction={
            data:"0x"+initializationCode+runcode
        }

        console.log(transaction.data)
        //await exploiterAcc.sendTransaction(transaction)
        await magicNum.setSolver(process.env.MAGIC_NUM_SOLUTION_ADDRESS)

    }else{
        console.log("This script can only be executed in rinkeby network")
    }
}

executeExploit().then(()=>process.exit(0)).catch(err=>console.log(err))
